"""
============================================================
ALPHA-PRIME v2.0 - Strategy Registry (Meta-Strategy)
============================================================

Centralized management for multiple trading strategies:

Why Multiple Strategies?
- Different strategies excel in different market regimes. [web:242][web:246][web:248]
- Ensemble methods reduce dependence on a single alpha source. [web:235][web:239][web:243]
- A/B testing helps identify and retire underperforming approaches. [web:242][web:246]
- Adaptability improves robustness across regime shifts. [web:240][web:244][web:242]

Strategy Types:
1. MOMENTUM:
   - Best in: Strong trends (BULL/BEAR regimes).
   - Signals: EMA crossovers, MACD, ADX.
   - Risk: Medium.

2. MEAN_REVERSION:
   - Best in: Sideways/choppy markets.
   - Signals: RSI oversold/overbought, Bollinger Bands.
   - Risk: Medium–High (counter-trend).

3. BREAKOUT:
   - Best in: Consolidation → trend transitions.
   - Signals: Support/resistance breaks, volume surges.
   - Risk: Medium (false breakouts).

4. SWING:
   - Best in: All conditions (multi-timeframe).
   - Signals: Confluence across 1h/4h/1d.
   - Risk: Low–Medium (high confirmation).

5. CONSERVATIVE:
   - Best in: High volatility, uncertain markets.
   - Signals: Same as others but higher thresholds.
   - Risk: Low (high bar for entry).

6. AGGRESSIVE:
   - Best in: Low volatility, clear trends.
   - Signals: Lower thresholds, larger positions.
   - Risk: High (more trades).

Strategy Selection Rules:
- BULL regime → Momentum or Aggressive.
- BEAR regime → Conservative or Mean Reversion (short bias).
- SIDEWAYS → Mean Reversion or Conservative.
- HIGH_VOL → Conservative only.
- UNKNOWN → Swing (multi-timeframe confirmation).

Ensemble Method:
- Poll multiple strategies for same ticker.
- Hard voting on BUY/SELL/WAIT with performance-based weights. [web:235][web:239][web:247]
- Confidence boost if strong consensus.
- Defer or reduce size if major disagreement.

Usage:
    from strategy.strategy_registry import (
        select_strategy_by_regime,
        get_ensemble_signal,
    )

    regime = get_current_regime()
    strategy = select_strategy_by_regime(regime)

    signal = strategy.generate_signal(ticker, intel, technicals, regime=regime)

    ensemble = get_ensemble_signal(ticker, intel, technicals, regime, ["MOMENTUM", "SWING", "MEAN_REVERSION"])
    if ensemble.consensus:
        print(f"Consensus: {ensemble.consensus_action} (confidence: {ensemble.final_confidence})")

Integration:
- brain.py uses registry to select strategy.
- Scheduler can A/B test strategies and rotate them.
- Dashboard displays live and historical strategy performance.
============================================================
"""

from __future__ import annotations

import logging
from abc import ABC, abstractmethod
from collections import defaultdict
from dataclasses import dataclass, field
from datetime import datetime, timedelta, timezone
from enum import Enum
from typing import Dict, List, Optional, Tuple

import numpy as np
import pandas as pd

from config import get_logger, get_settings

logger = get_logger(__name__)
settings = get_settings()


# ──────────────────────────────────────────────────────────
# DATA SCHEMAS & PROTOCOLS
# ──────────────────────────────────────────────────────────


class StrategyType(str, Enum):
    """Strategy type classification."""

    MOMENTUM = "MOMENTUM"
    MEAN_REVERSION = "MEAN_REVERSION"
    BREAKOUT = "BREAKOUT"
    SWING = "SWING"
    CONSERVATIVE = "CONSERVATIVE"
    AGGRESSIVE = "AGGRESSIVE"
    ENSEMBLE = "ENSEMBLE"


@dataclass
class StrategySignal:
    """
    Signal generated by a strategy.

    Attributes:
        strategy_name: Name of the strategy that produced this signal.
        action: "BUY" | "SELL" | "WAIT".
        confidence: Integer 0–100 expressing conviction.
        entry_price: Suggested entry price.
        stop_loss: Protective stop level.
        take_profits: One or more take-profit levels.
        rationale: Bullet-point explanation list.
        time_horizon: "INTRADAY" | "SWING" | "POSITION" etc.
        timestamp_utc: ISO-8601 timestamp.
    """

    strategy_name: str
    action: str
    confidence: int
    entry_price: float
    stop_loss: float
    take_profits: List[float]
    rationale: List[str]
    time_horizon: str
    timestamp_utc: str


@dataclass
class EnsembleSignal:
    """
    Aggregate signal from multiple strategies (ensemble).

    Attributes:
        ticker: Symbol under evaluation.
        individual_signals: All underlying StrategySignal objects.
        consensus_action: "BUY" | "SELL" | "WAIT" | "NO_CONSENSUS".
        consensus: True if at least 2/3 of weighted votes agree.
        average_confidence: Mean confidence across strategies.
        confidence_boost: Additional points applied for consensus.
        final_confidence: Combined confidence clipped to [0, 100].
        votes: Mapping action → raw vote count.
        rationale: Summary rationale including consensus explanation.
    """

    ticker: str
    individual_signals: List[StrategySignal]
    consensus_action: str
    consensus: bool
    average_confidence: int
    confidence_boost: int
    final_confidence: int
    votes: Dict[str, int]
    rationale: List[str]


@dataclass
class StrategyPerformance:
    """
    Performance metrics for a strategy.

    Intended to be updated from the portfolio subsystem after trades close.

    Attributes:
        strategy_name: Name of the strategy.
        total_trades: Number of closed trades.
        winning_trades: Count of trades with positive PnL.
        losing_trades: Count with negative or zero PnL.
        win_rate: Percentage of winning trades.
        avg_return: Average trade return (%) across all trades.
        sharpe_ratio: Approximate Sharpe ratio of the strategy.
        max_drawdown: Maximum equity drawdown (%) for this strategy.
        last_30_days_return: Return (%) over last 30 days.
        weight: Ensemble voting weight (0–1) derived from performance.
    """

    strategy_name: str
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    win_rate: float = 0.0
    avg_return: float = 0.0
    sharpe_ratio: float = 0.0
    max_drawdown: float = 0.0
    last_30_days_return: float = 0.0
    weight: float = 1.0


@dataclass
class StrategyConfig:
    """
    Configuration for a trading strategy.

    Attributes:
        name: Unique identifier.
        strategy_type: StrategyType enum.
        confidence_threshold: Minimum confidence for execution.
        position_size_multiplier: Factor applied to base position size.
        preferred_regimes: List of regimes where strategy tends to excel.
        avoid_regimes: Regimes where strategy should be de-prioritized.
        max_holding_period_days: Maximum intended holding period.
        enabled: Whether strategy is currently active.
        description: Human-friendly description of behavior.
    """

    name: str
    strategy_type: StrategyType
    confidence_threshold: int
    position_size_multiplier: float
    preferred_regimes: List[str]
    avoid_regimes: List[str]
    max_holding_period_days: int
    enabled: bool = True
    description: str = ""


class TradingStrategy(ABC):
    """
    Abstract base class for trading strategies.

    Each concrete strategy must implement:
        - generate_signal: to produce StrategySignal given inputs.
        - is_suitable_for_regime: to indicate if it fits a regime.
    """

    def __init__(self, config: StrategyConfig):
        self.config = config
        self.performance: StrategyPerformance = StrategyPerformance(
            strategy_name=config.name
        )
        self._trade_history: List[Dict[str, float]] = []

    @abstractmethod
    def generate_signal(
        self,
        ticker: str,
        intel: Dict,
        technicals: Dict,
        regime: str = "UNKNOWN",
    ) -> StrategySignal:
        """Generate a trading signal for a given ticker."""
        raise NotImplementedError

    @abstractmethod
    def is_suitable_for_regime(self, regime: str) -> bool:
        """Return True if strategy is appropriate for given regime."""
        raise NotImplementedError

    def update_performance(self, trade_result: Dict[str, float]) -> None:
        """
        Update internal performance metrics from a closed trade.

        trade_result should contain:
            - 'pnl_pct': percentage PnL for this trade.
            - 'closed_at': datetime or ISO timestamp (optional).
        """
        pnl_pct = float(trade_result.get("pnl_pct", 0.0))
        self._trade_history.append(trade_result)

        self.performance.total_trades += 1
        if pnl_pct > 0:
            self.performance.winning_trades += 1
        else:
            self.performance.losing_trades += 1

        if self.performance.total_trades > 0:
            self.performance.win_rate = (
                self.performance.winning_trades
                / self.performance.total_trades
                * 100.0
            )

        n = len(self._trade_history)
        returns = np.array([float(t.get("pnl_pct", 0.0)) for t in self._trade_history])
        self.performance.avg_return = float(np.mean(returns)) if n > 0 else 0.0
        if n > 1 and np.std(returns, ddof=1) != 0:
            self.performance.sharpe_ratio = float(
                np.mean(returns) / np.std(returns, ddof=1) * np.sqrt(max(n, 1))
            )
        else:
            self.performance.sharpe_ratio = 0.0

        equity = np.cumprod(1.0 + returns / 100.0)
        if equity.size > 1:
            running_max = np.maximum.accumulate(equity)
            dd = (equity - running_max) / running_max
            self.performance.max_drawdown = abs(float(np.min(dd))) * 100.0
        else:
            self.performance.max_drawdown = 0.0

        cutoff = datetime.now(timezone.utc) - timedelta(days=30)
        last_30 = [
            float(t.get("pnl_pct", 0.0))
            for t in self._trade_history
            if _parse_trade_time(t.get("closed_at", None)) >= cutoff
        ]
        self.performance.last_30_days_return = float(np.sum(last_30)) if last_30 else 0.0

        base = (
            self.performance.win_rate * 0.4
            + self.performance.sharpe_ratio * 20.0 * 0.4
            + self.performance.last_30_days_return * 0.2
        )
        weight = max(0.1, min(2.0, 0.5 + base / 100.0))
        self.performance.weight = float(weight)


def _parse_trade_time(value: Optional[object]) -> datetime:
    """Internal helper to parse trade timestamps."""
    if isinstance(value, datetime):
        if value.tzinfo is None:
            return value.replace(tzinfo=timezone.utc)
        return value
    if isinstance(value, str) and value:
        try:
            dt = datetime.fromisoformat(value)
            if dt.tzinfo is None:
                dt = dt.replace(tzinfo=timezone.utc)
            return dt
        except Exception:  # noqa: BLE001
            return datetime.now(timezone.utc)
    return datetime.now(timezone.utc)


# ──────────────────────────────────────────────────────────
# STRATEGY IMPLEMENTATIONS
# ──────────────────────────────────────────────────────────


class MomentumStrategy(TradingStrategy):
    """Trend-following momentum strategy."""

    def generate_signal(
        self,
        ticker: str,
        intel: Dict,
        technicals: Dict,
        regime: str = "UNKNOWN",
    ) -> StrategySignal:
        """
        Generate a momentum-based signal using trend and MACD.

        Inputs expected in `technicals`:
            technicals["trend"]["trend"] ∈ {"UP","DOWN","SIDEWAYS"}
            technicals["trend"]["adx"]   : float
            technicals["macd"]["signal"] ∈ {"BULLISH","BEARISH","NEUTRAL"}
            technicals["price_action"]["last_price"] : float
        """
        trend = technicals["trend"]["trend"]
        macd_signal = technicals["macd"]["signal"]
        adx = float(technicals["trend"].get("adx", 0.0))
        price = float(technicals["price_action"]["last_price"])

        action = "WAIT"
        confidence = 50
        rationale: List[str] = []

        if trend == "UP" and macd_signal == "BULLISH" and adx > 25.0:
            action = "BUY"
            confidence = 75
            rationale.append("Strong uptrend with bullish MACD and ADX > 25.")
            if adx > 40.0:
                confidence += 10
                rationale.append(f"Very strong trend (ADX={adx:.1f}).")
        elif trend == "DOWN" and macd_signal == "BEARISH" and adx > 25.0:
            action = "SELL"
            confidence = 70
            rationale.append("Strong downtrend with bearish MACD and ADX > 25.")
        else:
            rationale.append("No clear momentum alignment (trend/MACD/ADX).")

        stop_loss = price * (0.95 if action == "BUY" else 1.05)
        if action == "SELL":
            tps = [price * 0.97, price * 0.94, price * 0.90]
        else:
            tps = [price * 1.03, price * 1.05, price * 1.08]

        ts = datetime.now(timezone.utc).isoformat()
        return StrategySignal(
            strategy_name=self.config.name,
            action=action,
            confidence=min(100, confidence),
            entry_price=price,
            stop_loss=stop_loss,
            take_profits=tps,
            rationale=rationale,
            time_horizon="SWING",
            timestamp_utc=ts,
        )

    def is_suitable_for_regime(self, regime: str) -> bool:
        """Momentum works best in trending BULL/BEAR regimes."""
        return regime in ("BULL", "BEAR")


class MeanReversionStrategy(TradingStrategy):
    """Mean reversion strategy: buy dips, sell rips."""

    def generate_signal(
        self,
        ticker: str,
        intel: Dict,
        technicals: Dict,
        regime: str = "UNKNOWN",
    ) -> StrategySignal:
        """
        Generate a mean-reversion signal using RSI and Bollinger Bands.

        Inputs expected in `technicals`:
            technicals["momentum"]["rsi"]
            technicals["volatility"]["bb_position"] ∈ {"BELOW_LOWER","ABOVE_UPPER","MIDDLE"}
            technicals["price_action"]["last_price"]
        """
        rsi = float(technicals["momentum"]["rsi"])
        bb_position = technicals["volatility"]["bb_position"]
        price = float(technicals["price_action"]["last_price"])

        action = "WAIT"
        confidence = 50
        rationale: List[str] = []

        if rsi < 30.0 and bb_position == "BELOW_LOWER":
            action = "BUY"
            confidence = 75
            rationale.append(
                f"Oversold: RSI={rsi:.1f}, price below lower Bollinger Band."
            )
            if rsi < 25.0:
                confidence += 10
                rationale.append("Extremely oversold (RSI < 25).")
        elif rsi > 70.0 and bb_position == "ABOVE_UPPER":
            action = "SELL"
            confidence = 70
            rationale.append(
                f"Overbought: RSI={rsi:.1f}, price above upper Bollinger Band."
            )
        else:
            rationale.append("No strong mean-reversion setup detected.")

        stop_loss = price * (0.97 if action == "BUY" else 1.03)
        if action == "SELL":
            tps = [price * 0.99, price * 0.97, price * 0.95]
        else:
            tps = [price * 1.02, price * 1.03, price * 1.05]

        ts = datetime.now(timezone.utc).isoformat()
        return StrategySignal(
            strategy_name=self.config.name,
            action=action,
            confidence=min(100, confidence),
            entry_price=price,
            stop_loss=stop_loss,
            take_profits=tps,
            rationale=rationale,
            time_horizon="SHORT",
            timestamp_utc=ts,
        )

    def is_suitable_for_regime(self, regime: str) -> bool:
        """Mean reversion is most appropriate in SIDEWAYS regimes."""
        return regime == "SIDEWAYS"


class ConservativeStrategy(TradingStrategy):
    """Conservative strategy with high confirmation thresholds."""

    def generate_signal(
        self,
        ticker: str,
        intel: Dict,
        technicals: Dict,
        regime: str = "UNKNOWN",
    ) -> StrategySignal:
        """
        Generate conservative signal requiring strong indicator agreement.

        Inputs expected:
            technicals["trend"]["trend"]
            technicals["trend"]["adx"]
            technicals["macd"]["signal"]
            technicals["momentum"]["rsi"]
            technicals["price_action"]["last_price"]
        """
        trend = technicals["trend"]["trend"]
        adx = float(technicals["trend"].get("adx", 0.0))
        macd_signal = technicals["macd"]["signal"]
        rsi = float(technicals["momentum"]["rsi"])
        price = float(technicals["price_action"]["last_price"])

        action = "WAIT"
        confidence = 50
        rationale: List[str] = []

        if (
            trend == "UP"
            and macd_signal == "BULLISH"
            and 40.0 < rsi < 65.0
            and adx > 30.0
        ):
            action = "BUY"
            confidence = 85
            rationale.append("Conservative BUY: trend, MACD, RSI, ADX aligned.")
        elif (
            trend == "DOWN"
            and macd_signal == "BEARISH"
            and rsi < 55.0
            and adx > 30.0
        ):
            action = "SELL"
            confidence = 80
            rationale.append("Conservative SELL: downtrend confirmed by MACD & ADX.")
        else:
            rationale.append("Conservative criteria not met; prefer staying in cash.")

        stop_loss = price * (0.97 if action == "BUY" else 1.03)
        if action == "SELL":
            tps = [price * 0.98, price * 0.96, price * 0.94]
        else:
            tps = [price * 1.02, price * 1.04, price * 1.06]

        ts = datetime.now(timezone.utc).isoformat()
        return StrategySignal(
            strategy_name=self.config.name,
            action=action,
            confidence=min(100, confidence),
            entry_price=price,
            stop_loss=stop_loss,
            take_profits=tps,
            rationale=rationale,
            time_horizon="SWING",
            timestamp_utc=ts,
        )

    def is_suitable_for_regime(self, regime: str) -> bool:
        """Conservative approach is acceptable across all regimes."""
        return True


# Placeholder stubs for other strategy types, ready for future extension.


# ──────────────────────────────────────────────────────────
# STRATEGY REGISTRY
# ──────────────────────────────────────────────────────────


class StrategyRegistry:
    """
    Central registry for managing trading strategies.

    Responsibilities:
        - Hold references to all TradingStrategy instances.
        - Track performance and trade history meta-data.
        - Provide selection utilities and ensemble support.
    """

    def __init__(self) -> None:
        self.strategies: Dict[str, TradingStrategy] = {}
        self.performance_history: Dict[str, List[Dict]] = defaultdict(list)
        self._initialize_default_strategies()

    def _initialize_default_strategies(self) -> None:
        """Create and register default strategies."""
        momentum_config = StrategyConfig(
            name="MOMENTUM",
            strategy_type=StrategyType.MOMENTUM,
            confidence_threshold=70,
            position_size_multiplier=1.0,
            preferred_regimes=["BULL", "BEAR"],
            avoid_regimes=["SIDEWAYS", "HIGH_VOL"],
            max_holding_period_days=10,
            description="Trend-following momentum strategy.",
        )
        self.register_strategy("MOMENTUM", MomentumStrategy(momentum_config))

        mean_reversion_config = StrategyConfig(
            name="MEAN_REVERSION",
            strategy_type=StrategyType.MEAN_REVERSION,
            confidence_threshold=75,
            position_size_multiplier=0.8,
            preferred_regimes=["SIDEWAYS"],
            avoid_regimes=["BULL", "BEAR"],
            max_holding_period_days=3,
            description="Mean-reversion: buy dips, sell rips.",
        )
        self.register_strategy(
            "MEAN_REVERSION", MeanReversionStrategy(mean_reversion_config)
        )

        conservative_config = StrategyConfig(
            name="CONSERVATIVE",
            strategy_type=StrategyType.CONSERVATIVE,
            confidence_threshold=85,
            position_size_multiplier=0.7,
            preferred_regimes=["BULL", "BEAR", "SIDEWAYS", "HIGH_VOL", "UNKNOWN"],
            avoid_regimes=[],
            max_holding_period_days=7,
            description="High confirmation, low-risk strategy.",
        )
        self.register_strategy(
            "CONSERVATIVE", ConservativeStrategy(conservative_config)
        )

        logger.info("Initialized %d default strategies.", len(self.strategies))

    def register_strategy(self, name: str, strategy: TradingStrategy) -> None:
        """
        Register a strategy instance under a name.

        Args:
            name: Registry key (usually strategy.config.name).
            strategy: TradingStrategy instance.
        """
        self.strategies[name] = strategy
        logger.info("Registered strategy: %s.", name)

    def get_strategy(self, name: str) -> Optional[TradingStrategy]:
        """
        Retrieve a strategy by name.

        Args:
            name: Registry key.

        Returns:
            TradingStrategy instance or None if not found.
        """
        return self.strategies.get(name)

    def list_strategies(self) -> List[str]:
        """Return list of all strategy names."""
        return list(self.strategies.keys())

    def get_enabled_strategies(self) -> List[TradingStrategy]:
        """Return list of strategies with config.enabled == True."""
        return [s for s in self.strategies.values() if s.config.enabled]


_registry = StrategyRegistry()


def register_strategy(name: str, strategy: TradingStrategy) -> None:
    """Register a strategy globally via the singleton registry."""
    _registry.register_strategy(name, strategy)


def get_strategy(name: str) -> Optional[TradingStrategy]:
    """Get a strategy by name using the global registry."""
    return _registry.get_strategy(name)


def list_strategies() -> List[str]:
    """List all registered strategy names."""
    return _registry.list_strategies()


# ──────────────────────────────────────────────────────────
# REGIME-BASED STRATEGY SELECTION
# ──────────────────────────────────────────────────────────


def select_strategy_by_regime(regime: str) -> TradingStrategy:
    """
    Select an appropriate strategy based on market regime.

    Regime mapping:
        BULL     → MOMENTUM, AGGRESSIVE (if available).
        BEAR     → CONSERVATIVE, MOMENTUM.
        SIDEWAYS → MEAN_REVERSION, CONSERVATIVE.
        HIGH_VOL → CONSERVATIVE.
        UNKNOWN  → CONSERVATIVE.

    Args:
        regime: Regime string ("BULL","BEAR","SIDEWAYS","HIGH_VOL","UNKNOWN").

    Returns:
        TradingStrategy instance.
    """
    regime = regime.upper()
    logger.info("Selecting strategy for regime: %s.", regime)

    regime_preferences: Dict[str, List[str]] = {
        "BULL": ["MOMENTUM", "AGGRESSIVE"],
        "BEAR": ["CONSERVATIVE", "MOMENTUM"],
        "SIDEWAYS": ["MEAN_REVERSION", "CONSERVATIVE"],
        "HIGH_VOL": ["CONSERVATIVE"],
        "UNKNOWN": ["CONSERVATIVE"],
    }

    preferred = regime_preferences.get(regime, ["CONSERVATIVE"])
    for name in preferred:
        strat = get_strategy(name)
        if strat and strat.config.enabled and strat.is_suitable_for_regime(regime):
            logger.info("Selected strategy %s for regime %s.", name, regime)
            return strat

    fallback = get_strategy("CONSERVATIVE")
    if fallback is None:
        raise RuntimeError("No suitable strategies available in registry.")
    logger.warning("Falling back to CONSERVATIVE strategy for regime %s.", regime)
    return fallback


# ──────────────────────────────────────────────────────────
# ENSEMBLE SIGNAL GENERATION
# ──────────────────────────────────────────────────────────


def get_ensemble_signal(
    ticker: str,
    intel: Dict,
    technicals: Dict,
    regime: str = "UNKNOWN",
    strategies: Optional[List[str]] = None,
) -> EnsembleSignal:
    """
    Generate an ensemble signal by polling multiple strategies.

    Uses weighted hard voting:
        - Each strategy casts a vote for BUY/SELL/WAIT.
        - Vote weight = performance.weight * signal.confidence.
        - Consensus requires ≥ 66% of total weight on one action. [web:235][web:239][web:247]

    Args:
        ticker: Symbol under evaluation.
        intel: Additional information (news, fundamentals, etc.).
        technicals: Technical indicator snapshot.
        regime: Current regime string.
        strategies: Optional list of strategy names to include.

    Returns:
        EnsembleSignal with votes, consensus, and rationale.
    """
    if strategies is None:
        strat_objs = _registry.get_enabled_strategies()
    else:
        strat_objs = [get_strategy(n) for n in strategies if get_strategy(n)]

    if not strat_objs:
        raise ValueError("No strategies available for ensemble voting.")

    logger.info(
        "Generating ensemble signal for %s using %d strategies.",
        ticker,
        len(strat_objs),
    )

    signals: List[StrategySignal] = []
    weight_votes: Dict[str, float] = {"BUY": 0.0, "SELL": 0.0, "WAIT": 0.0}
    total_weight = 0.0
    total_confidence = 0

    for strat in strat_objs:
        try:
            sig = strat.generate_signal(ticker, intel, technicals, regime)
            signals.append(sig)
            w = strat.performance.weight * max(1, sig.confidence) / 100.0
            weight_votes[sig.action] = weight_votes.get(sig.action, 0.0) + w
            total_weight += w
            total_confidence += sig.confidence
            logger.debug(
                "Strategy %s voted %s (conf=%d, weight=%.3f).",
                strat.config.name,
                sig.action,
                sig.confidence,
                w,
            )
        except Exception as exc:  # noqa: BLE001
            logger.error(
                "Error generating signal from strategy %s: %s",
                strat.config.name,
                exc,
                exc_info=True,
            )

    if not signals:
        raise RuntimeError("No valid signals produced by ensemble strategies.")

    raw_votes: Dict[str, int] = {"BUY": 0, "SELL": 0, "WAIT": 0}
    for s in signals:
        raw_votes[s.action] = raw_votes.get(s.action, 0) + 1

    if total_weight <= 0:
        consensus = False
        consensus_action = "NO_CONSENSUS"
        consensus_ratio = 0.0
    else:
        best_action = max(weight_votes.items(), key=lambda kv: kv[1])[0]
        consensus_ratio = weight_votes[best_action] / total_weight
        consensus = consensus_ratio >= 0.66
        consensus_action = best_action if consensus else "NO_CONSENSUS"

    avg_conf = total_confidence // len(signals)
    confidence_boost = 15 if consensus else 0
    final_conf = min(100, int(avg_conf + confidence_boost))

    rationale: List[str] = []
    if consensus:
        rationale.append(
            f"✅ Consensus: {consensus_action} with {consensus_ratio*100:.1f}% of weighted votes."
        )
        for s in signals:
            if s.action == consensus_action:
                rationale.extend(s.rationale[:2])
    else:
        rationale.append(
            "⚠️ No strong consensus: "
            f"BUY={raw_votes['BUY']}, SELL={raw_votes['SELL']}, WAIT={raw_votes['WAIT']}."
        )

    return EnsembleSignal(
        ticker=ticker,
        individual_signals=signals,
        consensus_action=consensus_action,
        consensus=consensus,
        average_confidence=int(avg_conf),
        confidence_boost=confidence_boost,
        final_confidence=final_conf,
        votes=raw_votes,
        rationale=rationale,
    )


# ──────────────────────────────────────────────────────────
# PERFORMANCE & COMPARISON UTILITIES
# ──────────────────────────────────────────────────────────


def get_best_performing_strategy(lookback_days: int = 30) -> str:
    """
    Return the name of the best-performing strategy in recent history.

    Score:
        score = 0.3 * win_rate
              + 0.3 * (sharpe_ratio * 20)
              + 0.4 * last_30_days_return

    Args:
        lookback_days: Unused placeholder for future detailed analytics.

    Returns:
        Strategy name (default "CONSERVATIVE" if none found).
    """
    _ = lookback_days
    strategies = _registry.get_enabled_strategies()
    best_name = "CONSERVATIVE"
    best_score = -float("inf")

    for strat in strategies:
        perf = strat.performance
        score = (
            perf.win_rate * 0.3
            + perf.sharpe_ratio * 20.0 * 0.3
            + perf.last_30_days_return * 0.4
        )
        if score > best_score:
            best_score = score
            best_name = strat.config.name

    logger.info("Best performing strategy currently: %s (score=%.2f).", best_name, best_score)
    return best_name


def compare_strategies(
    strategies: List[str],
) -> pd.DataFrame:
    """
    Build a comparison table describing strategy performance.

    Args:
        strategies: List of strategy names to compare.

    Returns:
        pandas.DataFrame with metrics per strategy.
    """
    records: List[Dict[str, object]] = []

    for name in strategies:
        strat = get_strategy(name)
        if strat is None:
            continue
        perf = strat.performance
        records.append(
            {
                "Strategy": name,
                "Type": strat.config.strategy_type.value,
                "Win Rate": f"{perf.win_rate:.1f}%",
                "Total Trades": perf.total_trades,
                "Sharpe Ratio": f"{perf.sharpe_ratio:.2f}",
                "Max Drawdown": f"{perf.max_drawdown:.2f}%",
                "30D Return": f"{perf.last_30_days_return:+.2f}%",
                "Weight": f"{perf.weight:.2f}",
            }
        )

    return pd.DataFrame.from_records(records)


# ──────────────────────────────────────────────────────────
# PLACEHOLDER BACKTESTING STUBS
# ──────────────────────────────────────────────────────────


@dataclass
class BacktestResult:
    """
    Simplified backtest result summary.

    Attributes:
        strategy_name: Name of strategy tested.
        ticker: Symbol tested.
        period: Data period used (e.g. "1y").
        total_return: Portfolio return (%) over backtest.
        max_drawdown: Max drawdown (%).
        sharpe_ratio: Approx Sharpe ratio.
        trades: Number of trades executed.
    """

    strategy_name: str
    ticker: str
    period: str
    total_return: float
    max_drawdown: float
    sharpe_ratio: float
    trades: int


@dataclass
class ComparisonReport:
    """
    Comparison report for multiple strategies over multiple tickers.

    Attributes:
        strategies: Names of strategies evaluated.
        tickers: Symbols included in test set.
        results: Mapping (strategy → list of BacktestResult).
        generated_at_utc: ISO timestamp for report generation.
    """

    strategies: List[str]
    tickers: List[str]
    results: Dict[str, List[BacktestResult]]
    generated_at_utc: str


def backtest_strategy(
    strategy_name: str,
    ticker: str,
    period: str = "1y",
) -> BacktestResult:
    """
    Placeholder backtest hook for a strategy on a ticker.

    This function is intended to be integrated with the backtesting
    engine of ALPHA-PRIME; here it returns a dummy result for wiring.

    Args:
        strategy_name: Name of the strategy.
        ticker: Symbol to backtest.
        period: String period (e.g. "1y","6mo").

    Returns:
        BacktestResult with placeholder metrics.
    """
    logger.info(
        "Backtest placeholder: strategy=%s, ticker=%s, period=%s.",
        strategy_name,
        ticker,
        period,
    )
    return BacktestResult(
        strategy_name=strategy_name,
        ticker=ticker,
        period=period,
        total_return=0.0,
        max_drawdown=0.0,
        sharpe_ratio=0.0,
        trades=0,
    )


def compare_strategies_backtest(
    tickers: List[str],
    strategies: List[str],
    period: str = "1y",
) -> ComparisonReport:
    """
    Run placeholder backtests for several strategies and tickers.

    Args:
        tickers: List of symbols.
        strategies: List of strategy names.
        period: Backtest period string.

    Returns:
        ComparisonReport with placeholder BacktestResult entries.
    """
    results: Dict[str, List[BacktestResult]] = {}
    for strat_name in strategies:
        results[strat_name] = [
            backtest_strategy(strat_name, ticker, period=period) for ticker in tickers
        ]

    return ComparisonReport(
        strategies=strategies,
        tickers=tickers,
        results=results,
        generated_at_utc=datetime.now(timezone.utc).isoformat(),
    )


# ──────────────────────────────────────────────────────────
# CLI TOOL & TESTING
# ──────────────────────────────────────────────────────────


if __name__ == "__main__":
    print("\n" + "=" * 70)
    print("ALPHA-PRIME Strategy Registry")
    print("=" * 70 + "\n")

    print("Registered Strategies")
    print("-" * 70)
    for name in list_strategies():
        strat = get_strategy(name)
        if strat is None:
            continue
        cfg = strat.config
        print(f"\n{name}:")
        print(f"  Type                : {cfg.strategy_type.value}")
        print(f"  Description         : {cfg.description}")
        print(f"  Enabled             : {cfg.enabled}")
        print(f"  Confidence Threshold: {cfg.confidence_threshold}%")
        print(
            f"  Preferred Regimes   : {', '.join(cfg.preferred_regimes) or 'None'}"
        )
        print(f"  Avoid Regimes       : {', '.join(cfg.avoid_regimes) or 'None'}")

    print("\n" + "=" * 70)
    print("Regime-Based Strategy Selection")
    print("-" * 70)
    for regime in ["BULL", "BEAR", "SIDEWAYS", "HIGH_VOL", "UNKNOWN"]:
        strat = select_strategy_by_regime(regime)
        print(f"{regime:10} → {strat.config.name}")

    print("\n" + "=" * 70)
    print("Strategy Performance Snapshot")
    print("-" * 70)
    df = compare_strategies(list_strategies())
    if not df.empty:
        print(df.to_string(index=False))
    else:
        print("No performance data yet.")

    print("\n" + "=" * 70 + "\n")
